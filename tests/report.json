{"report": {"environment": {"Python": "3.6.1", "Platform": "Darwin-16.5.0-x86_64-i386-64bit"}, "tests": [{"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_simple1", "duration": 0.34899353981018066, "run_index": 0, "setup": {"name": "setup", "duration": 0.08686685562133789, "outcome": "passed"}, "call": {"name": "call", "duration": 0.17178082466125488, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.00347900390625, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_simple2", "duration": 0.14853477478027344, "run_index": 1, "setup": {"name": "setup", "duration": 0.016522884368896484, "outcome": "passed"}, "call": {"name": "call", "duration": 0.11188912391662598, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.003599882125854492, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_both_messages_at_once", "duration": 0.04403424263000488, "run_index": 2, "setup": {"name": "setup", "duration": 0.01862311363220215, "outcome": "passed"}, "call": {"name": "call", "duration": 0.003804922103881836, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.00298309326171875, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_partitioned_messages1", "duration": 0.14543771743774414, "run_index": 3, "setup": {"name": "setup", "duration": 0.015504837036132812, "outcome": "passed"}, "call": {"name": "call", "duration": 0.11007905006408691, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.0043489933013916016, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_partitioned_messages2", "duration": 0.15093779563903809, "run_index": 4, "setup": {"name": "setup", "duration": 0.018574237823486328, "outcome": "passed"}, "call": {"name": "call", "duration": 0.10946416854858398, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.004325151443481445, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_partitioned_messages3", "duration": 0.14809918403625488, "run_index": 5, "setup": {"name": "setup", "duration": 0.017734050750732422, "outcome": "passed"}, "call": {"name": "call", "duration": 0.10931110382080078, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.003319978713989258, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_partitioned_messages4", "duration": 0.15084481239318848, "run_index": 6, "setup": {"name": "setup", "duration": 0.017687082290649414, "outcome": "passed"}, "call": {"name": "call", "duration": 0.1121819019317627, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.003288745880126953, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_partitioned_messages5", "duration": 0.25005674362182617, "run_index": 7, "setup": {"name": "setup", "duration": 0.01641988754272461, "outcome": "passed"}, "call": {"name": "call", "duration": 0.2138810157775879, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.0033359527587890625, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_partitioned_messages6", "duration": 0.30192995071411133, "run_index": 8, "setup": {"name": "setup", "duration": 0.015790939331054688, "outcome": "passed"}, "call": {"name": "call", "duration": 0.26488304138183594, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.005465030670166016, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_partitioned_messages7", "duration": 0.6241223812103271, "run_index": 9, "setup": {"name": "setup", "duration": 0.017577171325683594, "outcome": "passed"}, "call": {"name": "call", "duration": 0.585334062576294, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.0036339759826660156, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_nick_user_parsing1", "duration": 0.14644074440002441, "run_index": 10, "setup": {"name": "setup", "duration": 0.01673126220703125, "outcome": "passed"}, "call": {"name": "call", "duration": 0.10966706275939941, "outcome": "failed", "longrepr": "self = <chirc.tests.test_connection.TestBasicConnection object at 0x104bba828>\nirc_session = <chirc.tests.common.IRCSession object at 0x104bba9b0>\n\n    def test_connect_nick_user_parsing1(self, irc_session):\n        \"\"\"\n            Tests that the server is actually parsing the NICK and USER parameters\n            (as opposed to just hardcoding \"nick1\" and \"user1\" which is used in\n            other tests.\n            \"\"\"\n    \n        client = irc_session.get_client(nodelay = True)\n    \n        client.send_raw([\"NICK nick42\\r\\n\",\n                         \"USER user42 * * :User Forty Two\\r\\n\"],\n                        wait=0.05)\n    \n        irc_session.get_reply(client, expect_code = replies.RPL_WELCOME, expect_nick=\"nick42\", expect_nparams = 1,\n>                             long_param_re= \"Welcome to the Internet Relay Network nick42!user42@.*\")\n\ntests/chirc/tests/test_connection.py:200: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:356: in get_reply\n    self.verify_reply(msg, expect_code, expect_nick, expect_nparams, expect_short_params, long_param_re, long_param_values)\ntests/chirc/tests/common.py:431: in verify_reply\n    long_param_re = long_param_re, long_param_values = long_param_values)\ntests/chirc/tests/common.py:404: in verify_message\n    self._assert_is_not_none(match, \"|||%s||| <-- Long parameter does not match regular expression: %s\" % (lp, lpre), irc_msg = msg)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104bba9b0>, a = None\nexplanation = '|||:Welcome to the Internet Relay Network nick42!nick42@localhost||| <-- Long parameter does not match regular expres...2@.*$\\n\\nMESSAGE: |||:MacBook-Pro-5.local 001 nick42 :Welcome to the Internet Relay Network nick42!nick42@localhost|||'\nirc_msg = <chirc.types.IRCMessage object at 0x104bbacc0>\n\n    def _assert_is_not_none(self, a, explanation, irc_msg = None):\n        if irc_msg is not None:\n            explanation = explanation + \"\\n\\nMESSAGE: {}\".format(irc_msg.raw(bookends=True))\n    \n>       assert a is not None, explanation\nE       AssertionError: |||:Welcome to the Internet Relay Network nick42!nick42@localhost||| <-- Long parameter does not match regular expression: ^:Welcome to the Internet Relay Network nick42!user42@.*$\nE       \nE       MESSAGE: |||:MacBook-Pro-5.local 001 nick42 :Welcome to the Internet Relay Network nick42!nick42@localhost|||\n\ntests/chirc/tests/common.py:56: AssertionError"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.0033111572265625, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_nick_user_parsing2", "duration": 0.25758862495422363, "run_index": 11, "setup": {"name": "setup", "duration": 0.017911195755004883, "outcome": "passed"}, "call": {"name": "call", "duration": 0.21871399879455566, "outcome": "failed", "longrepr": "self = <chirc.tests.test_connection.TestBasicConnection object at 0x104bba550>\nirc_session = <chirc.tests.common.IRCSession object at 0x104bba358>\n\n    def test_connect_nick_user_parsing2(self, irc_session):\n        \"\"\"\n            Tests that the server is actually parsing the NICK and USER parameters\n            (as opposed to just hardcoding \"nick1\" and \"user1\" which is used in\n            other tests. Additionally, partitions the messages.\n            \"\"\"\n    \n        client = irc_session.get_client(nodelay = True)\n    \n        client.send_raw([\"NICK nick4\",\n                         \"2\\r\\n\",\n                         \"USER user4\",\n                         \"2 * * :User Forty Two\\r\\n\"],\n                        wait=0.05)\n    \n        irc_session.get_reply(client, expect_code = replies.RPL_WELCOME, expect_nick=\"nick42\", expect_nparams = 1,\n>                             long_param_re= \"Welcome to the Internet Relay Network nick42!user42@.*\")\n\ntests/chirc/tests/test_connection.py:218: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:356: in get_reply\n    self.verify_reply(msg, expect_code, expect_nick, expect_nparams, expect_short_params, long_param_re, long_param_values)\ntests/chirc/tests/common.py:431: in verify_reply\n    long_param_re = long_param_re, long_param_values = long_param_values)\ntests/chirc/tests/common.py:404: in verify_message\n    self._assert_is_not_none(match, \"|||%s||| <-- Long parameter does not match regular expression: %s\" % (lp, lpre), irc_msg = msg)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104bba358>, a = None\nexplanation = '|||:Welcome to the Internet Relay Network nick42!nick42@localhost||| <-- Long parameter does not match regular expres...2@.*$\\n\\nMESSAGE: |||:MacBook-Pro-5.local 001 nick42 :Welcome to the Internet Relay Network nick42!nick42@localhost|||'\nirc_msg = <chirc.types.IRCMessage object at 0x104bba6a0>\n\n    def _assert_is_not_none(self, a, explanation, irc_msg = None):\n        if irc_msg is not None:\n            explanation = explanation + \"\\n\\nMESSAGE: {}\".format(irc_msg.raw(bookends=True))\n    \n>       assert a is not None, explanation\nE       AssertionError: |||:Welcome to the Internet Relay Network nick42!nick42@localhost||| <-- Long parameter does not match regular expression: ^:Welcome to the Internet Relay Network nick42!user42@.*$\nE       \nE       MESSAGE: |||:MacBook-Pro-5.local 001 nick42 :Welcome to the Internet Relay Network nick42!nick42@localhost|||\n\ntests/chirc/tests/common.py:56: AssertionError"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.003052234649658203, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_nick_user_parsing3", "duration": 0.5676891803741455, "run_index": 12, "setup": {"name": "setup", "duration": 0.015253067016601562, "outcome": "passed"}, "call": {"name": "call", "duration": 0.5343670845031738, "outcome": "failed", "longrepr": "self = <chirc.tests.test_connection.TestBasicConnection object at 0x104fa42e8>\nirc_session = <chirc.tests.common.IRCSession object at 0x104fa4d30>\n\n    def test_connect_nick_user_parsing3(self, irc_session):\n        \"\"\"\n            Tests that the server is actually parsing the NICK and USER parameters\n            (as opposed to just hardcoding \"nick1\" and \"user1\" which is used in\n            other tests. Additionally, partitions the messages.\n            \"\"\"\n    \n        client = irc_session.get_client(nodelay = True)\n    \n        client.send_raw([\"NICK nick4\",\n                         \"2\",\n                         \"4\",\n                         \"2\",\n                         \"\\r\\n\",\n                         \"USER user4\",\n                         \"2\",\n                         \"4\",\n                         \"2\",\n                         \" * * :User Four Thousand Two Hundred and Forty Two\\r\\n\"],\n                        wait=0.05)\n    \n        irc_session.get_reply(client, expect_code = replies.RPL_WELCOME, expect_nick=\"nick4242\", expect_nparams = 1,\n>                             long_param_re= \"Welcome to the Internet Relay Network nick4242!user4242@.*\")\n\ntests/chirc/tests/test_connection.py:242: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:356: in get_reply\n    self.verify_reply(msg, expect_code, expect_nick, expect_nparams, expect_short_params, long_param_re, long_param_values)\ntests/chirc/tests/common.py:431: in verify_reply\n    long_param_re = long_param_re, long_param_values = long_param_values)\ntests/chirc/tests/common.py:404: in verify_message\n    self._assert_is_not_none(match, \"|||%s||| <-- Long parameter does not match regular expression: %s\" % (lp, lpre), irc_msg = msg)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104fa4d30>, a = None\nexplanation = '|||:Welcome to the Internet Relay Network nick4242!nick4242@localhost||| <-- Long parameter does not match regular ex...n\\nMESSAGE: |||:MacBook-Pro-5.local 001 nick4242 :Welcome to the Internet Relay Network nick4242!nick4242@localhost|||'\nirc_msg = <chirc.types.IRCMessage object at 0x104fa4e10>\n\n    def _assert_is_not_none(self, a, explanation, irc_msg = None):\n        if irc_msg is not None:\n            explanation = explanation + \"\\n\\nMESSAGE: {}\".format(irc_msg.raw(bookends=True))\n    \n>       assert a is not None, explanation\nE       AssertionError: |||:Welcome to the Internet Relay Network nick4242!nick4242@localhost||| <-- Long parameter does not match regular expression: ^:Welcome to the Internet Relay Network nick4242!user4242@.*$\nE       \nE       MESSAGE: |||:MacBook-Pro-5.local 001 nick4242 :Welcome to the Internet Relay Network nick4242!nick4242@localhost|||\n\ntests/chirc/tests/common.py:56: AssertionError"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.0028159618377685547, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_nick_user_parsing4", "duration": 0.30020642280578613, "run_index": 13, "setup": {"name": "setup", "duration": 0.01543879508972168, "outcome": "passed"}, "call": {"name": "call", "duration": 0.2659740447998047, "outcome": "failed", "longrepr": "self = <chirc.tests.test_connection.TestBasicConnection object at 0x104fa4630>\nirc_session = <chirc.tests.common.IRCSession object at 0x104fa49b0>\n\n    def test_connect_nick_user_parsing4(self, irc_session):\n        \"\"\"\n            Tests that the server only uses the last NICK message sent during\n            the registration phase.\n            \"\"\"\n    \n        client = irc_session.get_client(nodelay = True)\n    \n        client.send_raw([\"NICK nick1\\r\\n\",\n                         \"NICK nick2\\r\\n\",\n                         \"NICK nick3\\r\\n\",\n                         \"NICK nick42\\r\\n\",\n                         \"USER user42 * * :User Forty Two\\r\\n\"],\n                        wait=0.05)\n    \n        irc_session.get_reply(client, expect_code = replies.RPL_WELCOME, expect_nick=\"nick42\", expect_nparams = 1,\n>                             long_param_re= \"Welcome to the Internet Relay Network nick42!user42@.*\")\n\ntests/chirc/tests/test_connection.py:260: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:356: in get_reply\n    self.verify_reply(msg, expect_code, expect_nick, expect_nparams, expect_short_params, long_param_re, long_param_values)\ntests/chirc/tests/common.py:431: in verify_reply\n    long_param_re = long_param_re, long_param_values = long_param_values)\ntests/chirc/tests/common.py:398: in verify_message\n    irc_msg = msg)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104fa49b0>, a = 'nick1'\nb = 'nick42'\nexplanation = 'Expected parameter #1 to be nick42, got nick1 instead\\n\\nMESSAGE: |||:MacBook-Pro-5.local 001 nick1 :Welcome to the Internet Relay Network nick1!nick1@localhost|||'\nirc_msg = <chirc.types.IRCMessage object at 0x104a9a860>\n\n    def _assert_equals(self, a, b, explanation, irc_msg = None):\n        if irc_msg is not None:\n            explanation = explanation + \"\\n\\nMESSAGE: {}\".format(irc_msg.raw(bookends=True))\n    \n>       assert a == b, explanation\nE       AssertionError: Expected parameter #1 to be nick42, got nick1 instead\nE       \nE       MESSAGE: |||:MacBook-Pro-5.local 001 nick1 :Welcome to the Internet Relay Network nick1!nick1@localhost|||\n\ntests/chirc/tests/common.py:44: AssertionError"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.003354787826538086, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_nick_user_parsing5", "duration": 0.30580878257751465, "run_index": 14, "setup": {"name": "setup", "duration": 0.017731904983520508, "outcome": "passed"}, "call": {"name": "call", "duration": 0.2671029567718506, "outcome": "failed", "longrepr": "self = <chirc.tests.test_connection.TestBasicConnection object at 0x104c851d0>\nirc_session = <chirc.tests.common.IRCSession object at 0x104c850f0>\n\n    def test_connect_nick_user_parsing5(self, irc_session):\n        \"\"\"\n            Tests that the server only uses the last USER message sent during\n            the registration phase.\n            \"\"\"\n    \n        client = irc_session.get_client(nodelay = True)\n    \n        client.send_raw([\"USER user1 * * :User One\\r\\n\",\n                         \"USER user2 * * :User Two\\r\\n\",\n                         \"USER user3 * * :User Three\\r\\n\",\n                         \"USER user42 * * :User Forty Two\\r\\n\",\n                         \"NICK nick42\\r\\n\",\n                         ],\n                        wait=0.05)\n    \n        irc_session.get_reply(client, expect_code = replies.RPL_WELCOME, expect_nick=\"nick42\", expect_nparams = 1,\n>                             long_param_re= \"Welcome to the Internet Relay Network nick42!user42@.*\")\n\ntests/chirc/tests/test_connection.py:279: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:356: in get_reply\n    self.verify_reply(msg, expect_code, expect_nick, expect_nparams, expect_short_params, long_param_re, long_param_values)\ntests/chirc/tests/common.py:431: in verify_reply\n    long_param_re = long_param_re, long_param_values = long_param_values)\ntests/chirc/tests/common.py:404: in verify_message\n    self._assert_is_not_none(match, \"|||%s||| <-- Long parameter does not match regular expression: %s\" % (lp, lpre), irc_msg = msg)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104c850f0>, a = None\nexplanation = '|||:Welcome to the Internet Relay Network nick42!nick42@localhost||| <-- Long parameter does not match regular expres...2@.*$\\n\\nMESSAGE: |||:MacBook-Pro-5.local 001 nick42 :Welcome to the Internet Relay Network nick42!nick42@localhost|||'\nirc_msg = <chirc.types.IRCMessage object at 0x104c859e8>\n\n    def _assert_is_not_none(self, a, explanation, irc_msg = None):\n        if irc_msg is not None:\n            explanation = explanation + \"\\n\\nMESSAGE: {}\".format(irc_msg.raw(bookends=True))\n    \n>       assert a is not None, explanation\nE       AssertionError: |||:Welcome to the Internet Relay Network nick42!nick42@localhost||| <-- Long parameter does not match regular expression: ^:Welcome to the Internet Relay Network nick42!user42@.*$\nE       \nE       MESSAGE: |||:MacBook-Pro-5.local 001 nick42 :Welcome to the Internet Relay Network nick42!nick42@localhost|||\n\ntests/chirc/tests/common.py:56: AssertionError"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.003242015838623047, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_no_unexpected_welcome1", "duration": 0.13931894302368164, "run_index": 15, "setup": {"name": "setup", "duration": 0.016412973403930664, "outcome": "passed"}, "call": {"name": "call", "duration": 0.10313200950622559, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.0033609867095947266, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_no_unexpected_welcome2", "duration": 0.1436622142791748, "run_index": 16, "setup": {"name": "setup", "duration": 0.016096115112304688, "outcome": "passed"}, "call": {"name": "call", "duration": 0.1073610782623291, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.004108905792236328, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_no_unexpected_welcome3", "duration": 0.25504541397094727, "run_index": 17, "setup": {"name": "setup", "duration": 0.01885080337524414, "outcome": "passed"}, "call": {"name": "call", "duration": 0.21362590789794922, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.0037178993225097656, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_no_unexpected_welcome4", "duration": 0.2546350955963135, "run_index": 18, "setup": {"name": "setup", "duration": 0.019343137741088867, "outcome": "passed"}, "call": {"name": "call", "duration": 0.2120959758758545, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.00385284423828125, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_no_unexpected_welcome5", "duration": 0.2479991912841797, "run_index": 19, "setup": {"name": "setup", "duration": 0.01588296890258789, "outcome": "passed"}, "call": {"name": "call", "duration": 0.21221113204956055, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.004022121429443359, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_no_unexpected_welcome6", "duration": 0.417649507522583, "run_index": 20, "setup": {"name": "setup", "duration": 0.018452167510986328, "outcome": "passed"}, "call": {"name": "call", "duration": 0.37680721282958984, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.003937959671020508, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestBasicConnection::()::test_connect_no_unexpected_welcome7", "duration": 0.41332221031188965, "run_index": 21, "setup": {"name": "setup", "duration": 0.018165111541748047, "outcome": "passed"}, "call": {"name": "call", "duration": 0.3734898567199707, "outcome": "passed"}, "metadata": [{"category": "BASIC_CONNECTION"}], "teardown": {"name": "teardown", "duration": 0.0035021305084228516, "outcome": "passed"}, "outcome": "passed"}, {"name": "tests/chirc/tests/test_connection.py::TestFullConnection::()::test_connect_full1", "duration": 0.04543709754943848, "run_index": 22, "setup": {"name": "setup", "duration": 0.018850088119506836, "outcome": "passed"}, "call": {"name": "call", "duration": 0.004889965057373047, "outcome": "failed", "longrepr": "self = <chirc.tests.common.IRCSession object at 0x104ccee80>\nclient = <chirc.client.ChircClient object at 0x104ccec50>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n>           msg = client.get_message()\n\ntests/chirc/tests/common.py:340: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.client.ChircClient object at 0x104ccec50>\n\n    def get_message(self):\n>       msg = self.client.read_until(str.encode(\"\\r\\n\"), timeout=self.msg_timeout)\n\ntests/chirc/client.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104ccecc0>, match = b'\\r\\n'\ntimeout = 0.09995298099238425\n\n    def read_until(self, match, timeout=None):\n        \"\"\"Read until a given string is encountered or until timeout.\n    \n            When no match is found, return whatever is available instead,\n            possibly the empty string.  Raise EOFError if the connection\n            is closed and no cooked data is available.\n    \n            \"\"\"\n        n = len(match)\n        self.process_rawq()\n        i = self.cookedq.find(match)\n        if i >= 0:\n            i = i+n\n            buf = self.cookedq[:i]\n            self.cookedq = self.cookedq[i:]\n            return buf\n        if timeout is not None:\n            deadline = _time() + timeout\n        with _TelnetSelector() as selector:\n            selector.register(self, selectors.EVENT_READ)\n            while not self.eof:\n                if selector.select(timeout):\n                    i = max(0, len(self.cookedq)-n)\n                    self.fill_rawq()\n                    self.process_rawq()\n                    i = self.cookedq.find(match, i)\n                    if i >= 0:\n                        i = i+n\n                        buf = self.cookedq[:i]\n                        self.cookedq = self.cookedq[i:]\n                        return buf\n                if timeout is not None:\n                    timeout = deadline - _time()\n                    if timeout < 0:\n                        break\n>       return self.read_very_lazy()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104ccecc0>\n\n    def read_very_lazy(self):\n        \"\"\"Return any data available in the cooked queue (very lazy).\n    \n            Raise EOFError if connection closed and no data available.\n            Return b'' if no cooked data available otherwise.  Don't block.\n    \n            \"\"\"\n        buf = self.cookedq\n        self.cookedq = b''\n        if not buf and self.eof and not self.rawq:\n>           raise EOFError('telnet connection closed')\nE           EOFError: telnet connection closed\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:403: EOFError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <chirc.tests.test_connection.TestFullConnection object at 0x104cd4c88>\nirc_session = <chirc.tests.common.IRCSession object at 0x104ccee80>\n\n    def test_connect_full1(self, irc_session):\n        \"\"\"\n            Checks that all welcome messages are sent after the NICK and USER\n            commands are received.\n            \"\"\"\n    \n        client = irc_session.get_client()\n    \n        client.send_cmd(\"NICK user1\")\n        client.send_cmd(\"USER user1 * * :User One\")\n    \n>       irc_session.verify_welcome_messages(client, \"user1\")\n\ntests/chirc/tests/test_connection.py:397: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:444: in verify_welcome_messages\n    reply = self.get_reply(client, expect_code = replies.RPL_YOURHOST, expect_nick = nick, expect_nparams = 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104ccee80>\nclient = <chirc.client.ChircClient object at 0x104ccec50>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n            msg = client.get_message()\n    \n            if expect_timeout:\n                pytest.fail(\"Was not expecting a reply, but got one:\\n\" + msg.raw(bookends=True))\n        except EOFError:\n>           pytest.fail(\"Server closed connection unexpectedly. Possible segfault in server?\")\nE           Failed: Server closed connection unexpectedly. Possible segfault in server?\n\ntests/chirc/tests/common.py:345: Failed"}, "metadata": [{"category": "CONNECTION_REGISTRATION"}], "teardown": {"name": "teardown", "duration": 0.002846956253051758, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestFullConnection::()::test_connect_full2", "duration": 0.03545832633972168, "run_index": 23, "setup": {"name": "setup", "duration": 0.014767169952392578, "outcome": "passed"}, "call": {"name": "call", "duration": 0.0029458999633789062, "outcome": "failed", "longrepr": "self = <chirc.tests.common.IRCSession object at 0x104f49b70>\nclient = <chirc.client.ChircClient object at 0x104f49a20>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n>           msg = client.get_message()\n\ntests/chirc/tests/common.py:340: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.client.ChircClient object at 0x104f49a20>\n\n    def get_message(self):\n>       msg = self.client.read_until(str.encode(\"\\r\\n\"), timeout=self.msg_timeout)\n\ntests/chirc/client.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104f49940>, match = b'\\r\\n'\ntimeout = 0.09996861102990806\n\n    def read_until(self, match, timeout=None):\n        \"\"\"Read until a given string is encountered or until timeout.\n    \n            When no match is found, return whatever is available instead,\n            possibly the empty string.  Raise EOFError if the connection\n            is closed and no cooked data is available.\n    \n            \"\"\"\n        n = len(match)\n        self.process_rawq()\n        i = self.cookedq.find(match)\n        if i >= 0:\n            i = i+n\n            buf = self.cookedq[:i]\n            self.cookedq = self.cookedq[i:]\n            return buf\n        if timeout is not None:\n            deadline = _time() + timeout\n        with _TelnetSelector() as selector:\n            selector.register(self, selectors.EVENT_READ)\n            while not self.eof:\n                if selector.select(timeout):\n                    i = max(0, len(self.cookedq)-n)\n                    self.fill_rawq()\n                    self.process_rawq()\n                    i = self.cookedq.find(match, i)\n                    if i >= 0:\n                        i = i+n\n                        buf = self.cookedq[:i]\n                        self.cookedq = self.cookedq[i:]\n                        return buf\n                if timeout is not None:\n                    timeout = deadline - _time()\n                    if timeout < 0:\n                        break\n>       return self.read_very_lazy()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104f49940>\n\n    def read_very_lazy(self):\n        \"\"\"Return any data available in the cooked queue (very lazy).\n    \n            Raise EOFError if connection closed and no data available.\n            Return b'' if no cooked data available otherwise.  Don't block.\n    \n            \"\"\"\n        buf = self.cookedq\n        self.cookedq = b''\n        if not buf and self.eof and not self.rawq:\n>           raise EOFError('telnet connection closed')\nE           EOFError: telnet connection closed\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:403: EOFError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <chirc.tests.test_connection.TestFullConnection object at 0x104cd4be0>\nirc_session = <chirc.tests.common.IRCSession object at 0x104f49b70>\n\n    def test_connect_full2(self, irc_session):\n        \"\"\"\n            Checks that all welcome messages are sent after the USER and NICK\n            commands are received.\n            \"\"\"\n    \n        client = irc_session.get_client()\n    \n        client.send_cmd(\"USER user1 * * :User One\")\n        client.send_cmd(\"NICK user1\")\n    \n>       irc_session.verify_welcome_messages(client, \"user1\")\n\ntests/chirc/tests/test_connection.py:410: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:444: in verify_welcome_messages\n    reply = self.get_reply(client, expect_code = replies.RPL_YOURHOST, expect_nick = nick, expect_nparams = 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104f49b70>\nclient = <chirc.client.ChircClient object at 0x104f49a20>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n            msg = client.get_message()\n    \n            if expect_timeout:\n                pytest.fail(\"Was not expecting a reply, but got one:\\n\" + msg.raw(bookends=True))\n        except EOFError:\n>           pytest.fail(\"Server closed connection unexpectedly. Possible segfault in server?\")\nE           Failed: Server closed connection unexpectedly. Possible segfault in server?\n\ntests/chirc/tests/common.py:345: Failed"}, "metadata": [{"category": "CONNECTION_REGISTRATION"}], "teardown": {"name": "teardown", "duration": 0.002978086471557617, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestFullConnection::()::test_connect_full3", "duration": 0.04139065742492676, "run_index": 24, "setup": {"name": "setup", "duration": 0.017206907272338867, "outcome": "passed"}, "call": {"name": "call", "duration": 0.004039764404296875, "outcome": "failed", "longrepr": "self = <chirc.tests.common.IRCSession object at 0x104f70eb8>\nclient = <chirc.client.ChircClient object at 0x104f706a0>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n>           msg = client.get_message()\n\ntests/chirc/tests/common.py:340: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.client.ChircClient object at 0x104f706a0>\n\n    def get_message(self):\n>       msg = self.client.read_until(str.encode(\"\\r\\n\"), timeout=self.msg_timeout)\n\ntests/chirc/client.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104f70668>, match = b'\\r\\n'\ntimeout = 0.09995021799113601\n\n    def read_until(self, match, timeout=None):\n        \"\"\"Read until a given string is encountered or until timeout.\n    \n            When no match is found, return whatever is available instead,\n            possibly the empty string.  Raise EOFError if the connection\n            is closed and no cooked data is available.\n    \n            \"\"\"\n        n = len(match)\n        self.process_rawq()\n        i = self.cookedq.find(match)\n        if i >= 0:\n            i = i+n\n            buf = self.cookedq[:i]\n            self.cookedq = self.cookedq[i:]\n            return buf\n        if timeout is not None:\n            deadline = _time() + timeout\n        with _TelnetSelector() as selector:\n            selector.register(self, selectors.EVENT_READ)\n            while not self.eof:\n                if selector.select(timeout):\n                    i = max(0, len(self.cookedq)-n)\n                    self.fill_rawq()\n                    self.process_rawq()\n                    i = self.cookedq.find(match, i)\n                    if i >= 0:\n                        i = i+n\n                        buf = self.cookedq[:i]\n                        self.cookedq = self.cookedq[i:]\n                        return buf\n                if timeout is not None:\n                    timeout = deadline - _time()\n                    if timeout < 0:\n                        break\n>       return self.read_very_lazy()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104f70668>\n\n    def read_very_lazy(self):\n        \"\"\"Return any data available in the cooked queue (very lazy).\n    \n            Raise EOFError if connection closed and no data available.\n            Return b'' if no cooked data available otherwise.  Don't block.\n    \n            \"\"\"\n        buf = self.cookedq\n        self.cookedq = b''\n        if not buf and self.eof and not self.rawq:\n>           raise EOFError('telnet connection closed')\nE           EOFError: telnet connection closed\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:403: EOFError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <chirc.tests.test_connection.TestFullConnection object at 0x104f70d30>\nirc_session = <chirc.tests.common.IRCSession object at 0x104f70eb8>\n\n    def test_connect_full3(self, irc_session):\n        \"\"\"\n            Checks that all welcome messages, as well as the LUSERS and\n            MOTD replies, are sent after the NICK and USER commands are received.\n            \"\"\"\n    \n        client = irc_session.get_client()\n    \n        client.send_cmd(\"NICK user1\")\n        client.send_cmd(\"USER user1 * * :User One\")\n    \n>       irc_session.verify_welcome_messages(client, \"user1\")\n\ntests/chirc/tests/test_connection.py:423: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:444: in verify_welcome_messages\n    reply = self.get_reply(client, expect_code = replies.RPL_YOURHOST, expect_nick = nick, expect_nparams = 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104f70eb8>\nclient = <chirc.client.ChircClient object at 0x104f706a0>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n            msg = client.get_message()\n    \n            if expect_timeout:\n                pytest.fail(\"Was not expecting a reply, but got one:\\n\" + msg.raw(bookends=True))\n        except EOFError:\n>           pytest.fail(\"Server closed connection unexpectedly. Possible segfault in server?\")\nE           Failed: Server closed connection unexpectedly. Possible segfault in server?\n\ntests/chirc/tests/common.py:345: Failed"}, "metadata": [{"category": "CONNECTION_REGISTRATION"}], "teardown": {"name": "teardown", "duration": 0.0029370784759521484, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestMultiuserConnection::()::test_connect_2users", "duration": 0.042583465576171875, "run_index": 25, "setup": {"name": "setup", "duration": 0.0178678035736084, "outcome": "passed"}, "call": {"name": "call", "duration": 0.003981828689575195, "outcome": "failed", "longrepr": "self = <chirc.tests.common.IRCSession object at 0x104c2b940>\nclient = <chirc.client.ChircClient object at 0x104c2ba20>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n>           msg = client.get_message()\n\ntests/chirc/tests/common.py:340: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.client.ChircClient object at 0x104c2ba20>\n\n    def get_message(self):\n>       msg = self.client.read_until(str.encode(\"\\r\\n\"), timeout=self.msg_timeout)\n\ntests/chirc/client.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104c2ba58>, match = b'\\r\\n'\ntimeout = 0.09994551492854953\n\n    def read_until(self, match, timeout=None):\n        \"\"\"Read until a given string is encountered or until timeout.\n    \n            When no match is found, return whatever is available instead,\n            possibly the empty string.  Raise EOFError if the connection\n            is closed and no cooked data is available.\n    \n            \"\"\"\n        n = len(match)\n        self.process_rawq()\n        i = self.cookedq.find(match)\n        if i >= 0:\n            i = i+n\n            buf = self.cookedq[:i]\n            self.cookedq = self.cookedq[i:]\n            return buf\n        if timeout is not None:\n            deadline = _time() + timeout\n        with _TelnetSelector() as selector:\n            selector.register(self, selectors.EVENT_READ)\n            while not self.eof:\n                if selector.select(timeout):\n                    i = max(0, len(self.cookedq)-n)\n                    self.fill_rawq()\n                    self.process_rawq()\n                    i = self.cookedq.find(match, i)\n                    if i >= 0:\n                        i = i+n\n                        buf = self.cookedq[:i]\n                        self.cookedq = self.cookedq[i:]\n                        return buf\n                if timeout is not None:\n                    timeout = deadline - _time()\n                    if timeout < 0:\n                        break\n>       return self.read_very_lazy()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104c2ba58>\n\n    def read_very_lazy(self):\n        \"\"\"Return any data available in the cooked queue (very lazy).\n    \n            Raise EOFError if connection closed and no data available.\n            Return b'' if no cooked data available otherwise.  Don't block.\n    \n            \"\"\"\n        buf = self.cookedq\n        self.cookedq = b''\n        if not buf and self.eof and not self.rawq:\n>           raise EOFError('telnet connection closed')\nE           EOFError: telnet connection closed\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:403: EOFError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <chirc.tests.test_connection.TestMultiuserConnection object at 0x104c2b588>\nirc_session = <chirc.tests.common.IRCSession object at 0x104c2b940>\n\n    def test_connect_2users(self, irc_session):\n        \"\"\"\n            Connects two clients to the server.\n            \"\"\"\n    \n>       irc_session.connect_user(\"user1\", \"User One\")\n\ntests/chirc/tests/test_connection.py:436: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:136: in connect_user\n    self.verify_welcome_messages(client, nick)\ntests/chirc/tests/common.py:444: in verify_welcome_messages\n    reply = self.get_reply(client, expect_code = replies.RPL_YOURHOST, expect_nick = nick, expect_nparams = 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104c2b940>\nclient = <chirc.client.ChircClient object at 0x104c2ba20>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n            msg = client.get_message()\n    \n            if expect_timeout:\n                pytest.fail(\"Was not expecting a reply, but got one:\\n\" + msg.raw(bookends=True))\n        except EOFError:\n>           pytest.fail(\"Server closed connection unexpectedly. Possible segfault in server?\")\nE           Failed: Server closed connection unexpectedly. Possible segfault in server?\n\ntests/chirc/tests/common.py:345: Failed"}, "metadata": [{"category": "CONNECTION_REGISTRATION"}], "teardown": {"name": "teardown", "duration": 0.002866029739379883, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestMultiuserConnection::()::test_connect_duplicate_nick", "duration": 0.0425570011138916, "run_index": 26, "setup": {"name": "setup", "duration": 0.018049001693725586, "outcome": "passed"}, "call": {"name": "call", "duration": 0.0034821033477783203, "outcome": "failed", "longrepr": "self = <chirc.tests.common.IRCSession object at 0x104f70898>\nclient = <chirc.client.ChircClient object at 0x104f70e48>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n>           msg = client.get_message()\n\ntests/chirc/tests/common.py:340: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.client.ChircClient object at 0x104f70e48>\n\n    def get_message(self):\n>       msg = self.client.read_until(str.encode(\"\\r\\n\"), timeout=self.msg_timeout)\n\ntests/chirc/client.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104f70c50>, match = b'\\r\\n'\ntimeout = 0.09996134601533413\n\n    def read_until(self, match, timeout=None):\n        \"\"\"Read until a given string is encountered or until timeout.\n    \n            When no match is found, return whatever is available instead,\n            possibly the empty string.  Raise EOFError if the connection\n            is closed and no cooked data is available.\n    \n            \"\"\"\n        n = len(match)\n        self.process_rawq()\n        i = self.cookedq.find(match)\n        if i >= 0:\n            i = i+n\n            buf = self.cookedq[:i]\n            self.cookedq = self.cookedq[i:]\n            return buf\n        if timeout is not None:\n            deadline = _time() + timeout\n        with _TelnetSelector() as selector:\n            selector.register(self, selectors.EVENT_READ)\n            while not self.eof:\n                if selector.select(timeout):\n                    i = max(0, len(self.cookedq)-n)\n                    self.fill_rawq()\n                    self.process_rawq()\n                    i = self.cookedq.find(match, i)\n                    if i >= 0:\n                        i = i+n\n                        buf = self.cookedq[:i]\n                        self.cookedq = self.cookedq[i:]\n                        return buf\n                if timeout is not None:\n                    timeout = deadline - _time()\n                    if timeout < 0:\n                        break\n>       return self.read_very_lazy()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104f70c50>\n\n    def read_very_lazy(self):\n        \"\"\"Return any data available in the cooked queue (very lazy).\n    \n            Raise EOFError if connection closed and no data available.\n            Return b'' if no cooked data available otherwise.  Don't block.\n    \n            \"\"\"\n        buf = self.cookedq\n        self.cookedq = b''\n        if not buf and self.eof and not self.rawq:\n>           raise EOFError('telnet connection closed')\nE           EOFError: telnet connection closed\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:403: EOFError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <chirc.tests.test_connection.TestMultiuserConnection object at 0x104f70ac8>\nirc_session = <chirc.tests.common.IRCSession object at 0x104f70898>\n\n    def test_connect_duplicate_nick(self, irc_session):\n        \"\"\"\n            Connects two clients to the server, but the second\n            client tries to use the first client's nickname\n            (and should get an ERR_NICKNAMEINUSE)\n            \"\"\"\n    \n>       client1 = irc_session.connect_user(\"user1\", \"User One\")\n\ntests/chirc/tests/test_connection.py:446: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:136: in connect_user\n    self.verify_welcome_messages(client, nick)\ntests/chirc/tests/common.py:444: in verify_welcome_messages\n    reply = self.get_reply(client, expect_code = replies.RPL_YOURHOST, expect_nick = nick, expect_nparams = 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x104f70898>\nclient = <chirc.client.ChircClient object at 0x104f70e48>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n            msg = client.get_message()\n    \n            if expect_timeout:\n                pytest.fail(\"Was not expecting a reply, but got one:\\n\" + msg.raw(bookends=True))\n        except EOFError:\n>           pytest.fail(\"Server closed connection unexpectedly. Possible segfault in server?\")\nE           Failed: Server closed connection unexpectedly. Possible segfault in server?\n\ntests/chirc/tests/common.py:345: Failed"}, "metadata": [{"category": "CONNECTION_REGISTRATION"}], "teardown": {"name": "teardown", "duration": 0.0029768943786621094, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestQUIT::()::test_quit_after_registration1", "duration": 0.043837547302246094, "run_index": 27, "setup": {"name": "setup", "duration": 0.01822829246520996, "outcome": "passed"}, "call": {"name": "call", "duration": 0.004488945007324219, "outcome": "failed", "longrepr": "self = <chirc.tests.common.IRCSession object at 0x1050e2748>\nclient = <chirc.client.ChircClient object at 0x1050e2860>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n>           msg = client.get_message()\n\ntests/chirc/tests/common.py:340: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.client.ChircClient object at 0x1050e2860>\n\n    def get_message(self):\n>       msg = self.client.read_until(str.encode(\"\\r\\n\"), timeout=self.msg_timeout)\n\ntests/chirc/client.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x1050e2cc0>, match = b'\\r\\n'\ntimeout = 0.09995201998390257\n\n    def read_until(self, match, timeout=None):\n        \"\"\"Read until a given string is encountered or until timeout.\n    \n            When no match is found, return whatever is available instead,\n            possibly the empty string.  Raise EOFError if the connection\n            is closed and no cooked data is available.\n    \n            \"\"\"\n        n = len(match)\n        self.process_rawq()\n        i = self.cookedq.find(match)\n        if i >= 0:\n            i = i+n\n            buf = self.cookedq[:i]\n            self.cookedq = self.cookedq[i:]\n            return buf\n        if timeout is not None:\n            deadline = _time() + timeout\n        with _TelnetSelector() as selector:\n            selector.register(self, selectors.EVENT_READ)\n            while not self.eof:\n                if selector.select(timeout):\n                    i = max(0, len(self.cookedq)-n)\n                    self.fill_rawq()\n                    self.process_rawq()\n                    i = self.cookedq.find(match, i)\n                    if i >= 0:\n                        i = i+n\n                        buf = self.cookedq[:i]\n                        self.cookedq = self.cookedq[i:]\n                        return buf\n                if timeout is not None:\n                    timeout = deadline - _time()\n                    if timeout < 0:\n                        break\n>       return self.read_very_lazy()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x1050e2cc0>\n\n    def read_very_lazy(self):\n        \"\"\"Return any data available in the cooked queue (very lazy).\n    \n            Raise EOFError if connection closed and no data available.\n            Return b'' if no cooked data available otherwise.  Don't block.\n    \n            \"\"\"\n        buf = self.cookedq\n        self.cookedq = b''\n        if not buf and self.eof and not self.rawq:\n>           raise EOFError('telnet connection closed')\nE           EOFError: telnet connection closed\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:403: EOFError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <chirc.tests.test_connection.TestQUIT object at 0x1050e25c0>\nirc_session = <chirc.tests.common.IRCSession object at 0x1050e2748>\n\n    def test_quit_after_registration1(self, irc_session):\n        \"\"\"\n            Connects a client, and quits right after connecting.\n            Verifies the ERROR response, but not whether the server\n            actually disconnected the client.\n            \"\"\"\n    \n>       client1 = irc_session.connect_user(\"user1\", \"User One\")\n\ntests/chirc/tests/test_connection.py:465: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:136: in connect_user\n    self.verify_welcome_messages(client, nick)\ntests/chirc/tests/common.py:444: in verify_welcome_messages\n    reply = self.get_reply(client, expect_code = replies.RPL_YOURHOST, expect_nick = nick, expect_nparams = 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x1050e2748>\nclient = <chirc.client.ChircClient object at 0x1050e2860>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n            msg = client.get_message()\n    \n            if expect_timeout:\n                pytest.fail(\"Was not expecting a reply, but got one:\\n\" + msg.raw(bookends=True))\n        except EOFError:\n>           pytest.fail(\"Server closed connection unexpectedly. Possible segfault in server?\")\nE           Failed: Server closed connection unexpectedly. Possible segfault in server?\n\ntests/chirc/tests/common.py:345: Failed"}, "metadata": [{"category": "CONNECTION_REGISTRATION"}], "teardown": {"name": "teardown", "duration": 0.002892017364501953, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestQUIT::()::test_quit_after_registration2", "duration": 0.03746366500854492, "run_index": 28, "setup": {"name": "setup", "duration": 0.015636205673217773, "outcome": "passed"}, "call": {"name": "call", "duration": 0.0033402442932128906, "outcome": "failed", "longrepr": "self = <chirc.tests.common.IRCSession object at 0x105013be0>\nclient = <chirc.client.ChircClient object at 0x104f1e240>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n>           msg = client.get_message()\n\ntests/chirc/tests/common.py:340: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.client.ChircClient object at 0x104f1e240>\n\n    def get_message(self):\n>       msg = self.client.read_until(str.encode(\"\\r\\n\"), timeout=self.msg_timeout)\n\ntests/chirc/client.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104f1e2b0>, match = b'\\r\\n'\ntimeout = 0.0999606519471854\n\n    def read_until(self, match, timeout=None):\n        \"\"\"Read until a given string is encountered or until timeout.\n    \n            When no match is found, return whatever is available instead,\n            possibly the empty string.  Raise EOFError if the connection\n            is closed and no cooked data is available.\n    \n            \"\"\"\n        n = len(match)\n        self.process_rawq()\n        i = self.cookedq.find(match)\n        if i >= 0:\n            i = i+n\n            buf = self.cookedq[:i]\n            self.cookedq = self.cookedq[i:]\n            return buf\n        if timeout is not None:\n            deadline = _time() + timeout\n        with _TelnetSelector() as selector:\n            selector.register(self, selectors.EVENT_READ)\n            while not self.eof:\n                if selector.select(timeout):\n                    i = max(0, len(self.cookedq)-n)\n                    self.fill_rawq()\n                    self.process_rawq()\n                    i = self.cookedq.find(match, i)\n                    if i >= 0:\n                        i = i+n\n                        buf = self.cookedq[:i]\n                        self.cookedq = self.cookedq[i:]\n                        return buf\n                if timeout is not None:\n                    timeout = deadline - _time()\n                    if timeout < 0:\n                        break\n>       return self.read_very_lazy()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x104f1e2b0>\n\n    def read_very_lazy(self):\n        \"\"\"Return any data available in the cooked queue (very lazy).\n    \n            Raise EOFError if connection closed and no data available.\n            Return b'' if no cooked data available otherwise.  Don't block.\n    \n            \"\"\"\n        buf = self.cookedq\n        self.cookedq = b''\n        if not buf and self.eof and not self.rawq:\n>           raise EOFError('telnet connection closed')\nE           EOFError: telnet connection closed\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:403: EOFError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <chirc.tests.test_connection.TestQUIT object at 0x105013cc0>\nirc_session = <chirc.tests.common.IRCSession object at 0x105013be0>\n\n    def test_quit_after_registration2(self, irc_session):\n        \"\"\"\n            Connects a client, and quits right after connecting.\n            Verifies the ERROR response and also checks whether the\n            server disconnected the client.\n            \"\"\"\n    \n>       client1 = irc_session.connect_user(\"user1\", \"User One\")\n\ntests/chirc/tests/test_connection.py:479: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:136: in connect_user\n    self.verify_welcome_messages(client, nick)\ntests/chirc/tests/common.py:444: in verify_welcome_messages\n    reply = self.get_reply(client, expect_code = replies.RPL_YOURHOST, expect_nick = nick, expect_nparams = 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x105013be0>\nclient = <chirc.client.ChircClient object at 0x104f1e240>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n            msg = client.get_message()\n    \n            if expect_timeout:\n                pytest.fail(\"Was not expecting a reply, but got one:\\n\" + msg.raw(bookends=True))\n        except EOFError:\n>           pytest.fail(\"Server closed connection unexpectedly. Possible segfault in server?\")\nE           Failed: Server closed connection unexpectedly. Possible segfault in server?\n\ntests/chirc/tests/common.py:345: Failed"}, "metadata": [{"category": "CONNECTION_REGISTRATION"}], "teardown": {"name": "teardown", "duration": 0.0028510093688964844, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestQUIT::()::test_quit_after_registration3", "duration": 0.03903603553771973, "run_index": 29, "setup": {"name": "setup", "duration": 0.016440153121948242, "outcome": "passed"}, "call": {"name": "call", "duration": 0.0032269954681396484, "outcome": "failed", "longrepr": "self = <chirc.tests.common.IRCSession object at 0x1050b7b70>\nclient = <chirc.client.ChircClient object at 0x1050b7cf8>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n>           msg = client.get_message()\n\ntests/chirc/tests/common.py:340: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.client.ChircClient object at 0x1050b7cf8>\n\n    def get_message(self):\n>       msg = self.client.read_until(str.encode(\"\\r\\n\"), timeout=self.msg_timeout)\n\ntests/chirc/client.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x1050b7e80>, match = b'\\r\\n'\ntimeout = 0.09994291397742927\n\n    def read_until(self, match, timeout=None):\n        \"\"\"Read until a given string is encountered or until timeout.\n    \n            When no match is found, return whatever is available instead,\n            possibly the empty string.  Raise EOFError if the connection\n            is closed and no cooked data is available.\n    \n            \"\"\"\n        n = len(match)\n        self.process_rawq()\n        i = self.cookedq.find(match)\n        if i >= 0:\n            i = i+n\n            buf = self.cookedq[:i]\n            self.cookedq = self.cookedq[i:]\n            return buf\n        if timeout is not None:\n            deadline = _time() + timeout\n        with _TelnetSelector() as selector:\n            selector.register(self, selectors.EVENT_READ)\n            while not self.eof:\n                if selector.select(timeout):\n                    i = max(0, len(self.cookedq)-n)\n                    self.fill_rawq()\n                    self.process_rawq()\n                    i = self.cookedq.find(match, i)\n                    if i >= 0:\n                        i = i+n\n                        buf = self.cookedq[:i]\n                        self.cookedq = self.cookedq[i:]\n                        return buf\n                if timeout is not None:\n                    timeout = deadline - _time()\n                    if timeout < 0:\n                        break\n>       return self.read_very_lazy()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x1050b7e80>\n\n    def read_very_lazy(self):\n        \"\"\"Return any data available in the cooked queue (very lazy).\n    \n            Raise EOFError if connection closed and no data available.\n            Return b'' if no cooked data available otherwise.  Don't block.\n    \n            \"\"\"\n        buf = self.cookedq\n        self.cookedq = b''\n        if not buf and self.eof and not self.rawq:\n>           raise EOFError('telnet connection closed')\nE           EOFError: telnet connection closed\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:403: EOFError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <chirc.tests.test_connection.TestQUIT object at 0x1050b7b38>\nirc_session = <chirc.tests.common.IRCSession object at 0x1050b7b70>\n\n    def test_quit_after_registration3(self, irc_session):\n        \"\"\"\n            Connects a client, and quits right after connecting.\n            QUIT does not specify a message, so the default \"Client Quit\" should\n            be assumed. Also verifies the ERROR response and also checks whether the\n            server disconnected the client.\n            \"\"\"\n    \n>       client1 = irc_session.connect_user(\"user1\", \"User One\")\n\ntests/chirc/tests/test_connection.py:496: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:136: in connect_user\n    self.verify_welcome_messages(client, nick)\ntests/chirc/tests/common.py:444: in verify_welcome_messages\n    reply = self.get_reply(client, expect_code = replies.RPL_YOURHOST, expect_nick = nick, expect_nparams = 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x1050b7b70>\nclient = <chirc.client.ChircClient object at 0x1050b7cf8>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n            msg = client.get_message()\n    \n            if expect_timeout:\n                pytest.fail(\"Was not expecting a reply, but got one:\\n\" + msg.raw(bookends=True))\n        except EOFError:\n>           pytest.fail(\"Server closed connection unexpectedly. Possible segfault in server?\")\nE           Failed: Server closed connection unexpectedly. Possible segfault in server?\n\ntests/chirc/tests/common.py:345: Failed"}, "metadata": [{"category": "CONNECTION_REGISTRATION"}], "teardown": {"name": "teardown", "duration": 0.0029287338256835938, "outcome": "passed"}, "outcome": "failed"}, {"name": "tests/chirc/tests/test_connection.py::TestQUIT::()::test_quit_after_registration4", "duration": 0.04198479652404785, "run_index": 30, "setup": {"name": "setup", "duration": 0.01763296127319336, "outcome": "passed"}, "call": {"name": "call", "duration": 0.003238201141357422, "outcome": "failed", "longrepr": "self = <chirc.tests.common.IRCSession object at 0x105026eb8>\nclient = <chirc.client.ChircClient object at 0x1050267f0>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n>           msg = client.get_message()\n\ntests/chirc/tests/common.py:340: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.client.ChircClient object at 0x1050267f0>\n\n    def get_message(self):\n>       msg = self.client.read_until(str.encode(\"\\r\\n\"), timeout=self.msg_timeout)\n\ntests/chirc/client.py:34: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x105026940>, match = b'\\r\\n'\ntimeout = 0.09995981503743678\n\n    def read_until(self, match, timeout=None):\n        \"\"\"Read until a given string is encountered or until timeout.\n    \n            When no match is found, return whatever is available instead,\n            possibly the empty string.  Raise EOFError if the connection\n            is closed and no cooked data is available.\n    \n            \"\"\"\n        n = len(match)\n        self.process_rawq()\n        i = self.cookedq.find(match)\n        if i >= 0:\n            i = i+n\n            buf = self.cookedq[:i]\n            self.cookedq = self.cookedq[i:]\n            return buf\n        if timeout is not None:\n            deadline = _time() + timeout\n        with _TelnetSelector() as selector:\n            selector.register(self, selectors.EVENT_READ)\n            while not self.eof:\n                if selector.select(timeout):\n                    i = max(0, len(self.cookedq)-n)\n                    self.fill_rawq()\n                    self.process_rawq()\n                    i = self.cookedq.find(match, i)\n                    if i >= 0:\n                        i = i+n\n                        buf = self.cookedq[:i]\n                        self.cookedq = self.cookedq[i:]\n                        return buf\n                if timeout is not None:\n                    timeout = deadline - _time()\n                    if timeout < 0:\n                        break\n>       return self.read_very_lazy()\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <telnetlib.Telnet object at 0x105026940>\n\n    def read_very_lazy(self):\n        \"\"\"Return any data available in the cooked queue (very lazy).\n    \n            Raise EOFError if connection closed and no data available.\n            Return b'' if no cooked data available otherwise.  Don't block.\n    \n            \"\"\"\n        buf = self.cookedq\n        self.cookedq = b''\n        if not buf and self.eof and not self.rawq:\n>           raise EOFError('telnet connection closed')\nE           EOFError: telnet connection closed\n\n/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/telnetlib.py:403: EOFError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <chirc.tests.test_connection.TestQUIT object at 0x105026518>\nirc_session = <chirc.tests.common.IRCSession object at 0x105026eb8>\n\n    def test_quit_after_registration4(self, irc_session):\n        \"\"\"\n            Connects two clients, and then has them quit, each with separate\n            messages.\n            \"\"\"\n    \n>       client1 = irc_session.connect_user(\"user1\", \"User One\")\n\ntests/chirc/tests/test_connection.py:512: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\ntests/chirc/tests/common.py:136: in connect_user\n    self.verify_welcome_messages(client, nick)\ntests/chirc/tests/common.py:444: in verify_welcome_messages\n    reply = self.get_reply(client, expect_code = replies.RPL_YOURHOST, expect_nick = nick, expect_nparams = 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <chirc.tests.common.IRCSession object at 0x105026eb8>\nclient = <chirc.client.ChircClient object at 0x1050267f0>, expect_code = '002'\nexpect_nick = 'user1', expect_nparams = 1, expect_short_params = None\nlong_param_re = None, long_param_values = None, expect_timeout = False\n\n    def get_reply(self, client, expect_code = None, expect_nick = None, expect_nparams = None,\n                  expect_short_params = None, long_param_re = None, long_param_values = None,\n                  expect_timeout = False):\n        try:\n            msg = client.get_message()\n    \n            if expect_timeout:\n                pytest.fail(\"Was not expecting a reply, but got one:\\n\" + msg.raw(bookends=True))\n        except EOFError:\n>           pytest.fail(\"Server closed connection unexpectedly. Possible segfault in server?\")\nE           Failed: Server closed connection unexpectedly. Possible segfault in server?\n\ntests/chirc/tests/common.py:345: Failed"}, "metadata": [{"category": "CONNECTION_REGISTRATION"}], "teardown": {"name": "teardown", "duration": 0.003480672836303711, "outcome": "passed"}, "outcome": "failed"}], "summary": {"passed": 17, "failed": 14, "num_tests": 31, "duration": 6.814281225204468}, "created_at": "2017-09-08 17:36:32.979114"}}